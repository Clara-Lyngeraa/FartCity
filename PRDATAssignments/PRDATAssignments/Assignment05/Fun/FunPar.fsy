%{
 (* File Fun/FunPar.fsy 
    Parser for micro-ML, a small functional language; one-argument functions.
    sestoft@itu.dk * 2009-10-19
  *)

 open Absyn;
%}

%token <int> CSTINT
%token <string> NAME
%token <string> STRINGNAME
%token <bool> CSTBOOL
%token ELSE END FALSE IF IN LET NOT THEN TRUE FUN
%token PLUS MINUS TIMES DIV MOD
%token EQ NE GT LT GE LE ARROW
%token LPAR RPAR 
%token EOF
%token LBRACK RBRACK COMMA WITHN
%token DOT FIELD RECORD LTUBRACK RTUBRACK SEMICOLON

%left ELSE
%right ARROW /* Right-associative operator */
%left EQ NE
%left GT LT GE LE WITHIN LTUBRACK RTUBRACK
%left PLUS MINUS
%left TIMES DIV MOD
%left IF
%left DOT FIELD RECORD SEMICOLON 
%left LET
%nonassoc NOT 

%start Main
%type <Absyn.expr> Main Expr AtExpr Const
%type <Absyn.expr> AppExpr



%%

Main:
    Expr EOF                            { $1 }
;

Expr:
    AtExpr                              { $1                     }
  | AppExpr                             { $1                     }
  | IF Expr THEN Expr ELSE Expr         { If($2, $4, $6)         }
  | MINUS Expr                          { Prim("-", CstI 0, $2)  }
  | Expr PLUS  Expr                     { Prim("+",  $1, $3)     }
  | Expr MINUS Expr                     { Prim("-",  $1, $3)     }
  | Expr TIMES Expr                     { Prim("*",  $1, $3)     }
  | Expr DIV   Expr                     { Prim("/",  $1, $3)     } 
  | Expr MOD   Expr                     { Prim("%",  $1, $3)     }
  | Expr EQ    Expr                     { Prim("=",  $1, $3)     }
  | Expr NE    Expr                     { Prim("<>", $1, $3)     }
  | Expr GT    Expr                     { Prim(">",  $1, $3)     }
  | Expr LT    Expr                     { Prim("<",  $1, $3)     }
  | Expr GE    Expr                     { Prim(">=", $1, $3)     }
  | Expr LE    Expr                     { Prim("<=", $1, $3)     }
  | FUN NAME ARROW Expr                 { Fun($2, $4)     }
  | Expr WITHN LBRACK Expr COMMA Expr RBRACK { InCheck($1,$4,$6)}
  | Expr DOT STRINGNAME                      { Field($1, $3)}
  | LTUBRACK FieldExprSeq RTUBRACK                 { Record($2) }
;

//RAOO 

Fields:
                              { [] }
  | STRINGNAME EQ Expr                   { [($1, $3)] }
  | STRINGNAME EQ Expr SEMICOLON Fields   { ($1, $3) :: $5 }
;

// NIELS LÃ˜SNING
FieldExprSeq:
                                   { [] }
  | FieldEqExpr                   { [$1] }
  | FieldEqExpr SEMICOLON FieldExprSeq   { $1 :: $3 }
;

FieldEqExpr:
    NAME EQ Expr { ($1, $3) }
;


AtExpr:
    Const                               { $1                     }
  | NAME                                { Var $1                 }
  | LET NAME EQ Expr IN Expr END        { Let($2, $4, $6)        }
  | LET NAME NAME EQ Expr IN Expr END   { Letfun($2, $3, $5, $7) }
  | LPAR Expr RPAR                      { $2                     }
;

AppExpr:
    AtExpr AtExpr                       { Call($1, $2)           }
  | AppExpr AtExpr                      { Call($1, $2)           }
;

Const:
    CSTINT                              { CstI($1)               }
  | CSTBOOL                             { CstB($1)               }
;
